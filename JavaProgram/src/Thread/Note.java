package Thread;
/*
多线程概述：
    1、什么是进程？什么是线程？
        进程是一个应用程序
        线程是一个进程中的执行场景/执行单元
        一个进程可以启动多个线程
    2、对于java程序来说，当在DOS命令窗口中输入；
        java HelloWorld回车之后，
        会先启动一个主线程调用main方法。
        同时在启动一个垃圾回收线程负责看护，回收垃圾。
        最起码，现在的java程序中至少有两个线程并发，
        一个是垃圾回收线程，一个是执行main方法的主线程
    3、进程A和进程B的内存独立不共享
        线程A和线程B，在java语言中：线程A和线程B：堆内存和方法区内存共享，但是堆内存独立，一个线程一个栈
    4、实现线程的两种方式
        第一：编写一个类，继承java.lang.Thread，重写run方法
        第二：编写一个类，实现java.lang.Runnable接口
了解内容
线程的调度：
    1、常见的线程调度有两种
        抢占式调度模型：
            哪个线程的优先级比较高，抢到的时间片的概率就高一些
            java采用的就是抢占式调度模型
        均分式调度模型：
            平均分配CPU时间片，每个线程占有的CPU时间片时间长度一样
            平均分配，一切平等
    2、java中提供了一些和线程调度有关的方法
        实例方法：
            void setPriority(int new Priority)  设置线程的优先级
            int getPriority()   获取线程优先级
            最低优先级1
            默认优先级5
            最高优先级10
            优先级比较高的获取CPU时间片可能会多一些（但也不完全是）
            void join()     合并线程
                class MyThread1 extends Thread {
                    public void doSome() {
                        MyThrad2 t = new MyThread2();
                        t.join();   //当前线程进入阻塞，t线程执行，直到t线程结束，当前线程才可以继续
                    }
                }

                class MyThread2 extend Thread {
                }
        静态方法：
            static void yield() 让位方法
            暂停当前正在执行的线程对象，并执行其他线程
            yield()方法不是阻塞方法，让当前线程让位，让给其他线程使用
            yield()方法的执行会让当前线程从”运行状态“回到”就绪状态“

重点：关于多线程并发环境下，数据的安全问题
    1、为什么这个是重点
        以后在开发中，我们的项目都是运行在服务器当中，而服务器已经将线程的定义，线程对象的创建，线程的启动等，都已经实现了。不需要我们编写
        最重要的是：你要知道，你编写的程序需要放到一个多线程的环境下运行，你更需要关注的是这些数据在多线程并发的环境下是否是安全的。（重点：*****）
    2、什么时候数据在多线程并发的环境下存在安全问题
        1、多线程并发
        2、有共享数据
        3、共享数据有修改行为
    3、怎么解决线程安全问题
        当多线程并发的环境下，有共享数据，并且这个数据会被修改，此时就存在线程安全问题，如何解决这个问题？
            线程排队执行。（不能并发）
            用排队执行解决线程安全问题
            这种机制被称为：线程同步机制

            专业术语叫：线程同步，实际上就是线程不能并发了，必须排队执行
        线程同步会牺牲一部分效率，没办法，数据安全是第一位
    4、线程同步这块，涉及到两个专业术语
        异步编程模型：
            线程t1和t2，各自执行各自的，谁也不需要等谁，
            其实就是多线程并发（效率较高）
        同步编程模型：
            t1执行时，必须等待t2执行结束，t2执行时，必须等待t1执行结束，两个线程之间发生了等待关系
            效率较低，线程排队执行

            异步就是并发，同步就是排队
    5、Java中有三大变量：
        实例变量：堆中
        静态变量：方法区中
        局部变量：栈中
        以上三大变量中：局部变量永远都不会存在线程安全问题，因为局部变量不共享（一个线程一个栈）
        堆和方法区只有1个，都是多线程共享，所以可能存在线程安全问题
    6、如果使用局部变量的话
        建议使用StringBuilder，因为局部变量不存在线程安全问题，使用StringBuffer的话效率会降低

    7、总结
        synchronized有三种写法
            第一种：同步代码块
                灵活
                synchronized(线程共享对象) {
                    同步代码块；
                }
            第二种：在实例方法上使用synchronized
                表示共享对象一定是this
                并且同步代码块是整个方法体
            第三种：在静态方法上使用synchronized
                表示找类锁
                类锁永远只有1把
                就算常见了100个对象，类锁爷只有一把
            对象锁：1个对象1把锁
            类锁：1个类一把锁
    8、开发中如何解决线程安全问题？
        synchronized会让程序的执行效率降低，在不得以的情况下再使用
        第一种：尽量使用局部变量代替“实例变量和静态变量”
        第二种：如果必须是实例变量，那么可以考虑创建多个对象，这样实例变量的内存就不共享了
        第三种：如果不能使用局部变量，对象也不能创建多个，这个时候就只能选择synchronized，线程同步机制
    9、线程这块其他内容
        1、守护线程
        2、定时器
        3、实现线程的第三种方式：FutureTask方式，实现Callable接口。（JDK8新特性）
        4、关于Object类中的wait和notify方法。（生产者和消费者模式）

 */
public class Note {

}
